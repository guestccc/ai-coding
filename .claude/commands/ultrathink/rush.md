# Rush Mode (冲刺模式) v1.2.0

**适用场景**: 时间紧迫的快速开发，MVP优先策略
**核心理念**: 最小可用产品，快速交付，后续迭代

## 🎯 模式特征

### 核心原则
```yaml
时间优先: 功能实现 > 代码优雅 > 完美设计
MVP策略: P0功能完整 > P1功能简化 > P2功能跳过
快速迭代: 先跑通 > 再优化 > 后完善
务实导向: 能用就行 > 最佳实践 > 架构设计
```

### 适用条件
```yaml
时间约束: 剩余交互次数 ≤ 6次
项目类型: 快速原型、概念验证、学习项目
质量要求: 基本可用即可
团队情况: 时间紧张、需要快速看到结果
```

## 🚀 行为调节策略

### Agent行为简化
```yaml
product-manager Agent:
  PRD文档: 核心需求为主，跳过详细分析
  用户故事: 仅主流程，忽略边界情况
  验收标准: 基本功能验收，简化测试

architect Agent:  
  架构设计: 选择熟悉技术栈，避免复杂架构
  技术选型: 快速选择，避免过度评估
  API设计: 基础CRUD，跳过高级特性

ui-designer Agent:
  原型设计: 基础页面布局，复用现有组件
  设计系统: 使用默认样式，最小化定制
  交互设计: 标准模式，跳过复杂交互

frontend-developer Agent:
  组件开发: 功能优先，简化状态管理
  代码结构: 快速实现，暂缓重构
  测试策略: 基础测试，60%覆盖率目标

backend-developer Agent:
  API实现: 核心功能实现，简化错误处理
  数据模型: 基础CRUD，暂缓复杂关联
  安全措施: 基础认证，简化权限控制

integration Agent:
  测试范围: 核心流程测试，跳过边界测试
  质量检查: 功能可用性优先
  性能要求: 基本性能满足即可
```

### 命令执行简化
```yaml
文档生成命令:
  /ut:generate/prd: 简化版PRD，核心功能清单
  /ut:generate/arch: 基础架构，技术栈选择
  /ut:generate/api: 基础API定义，标准CRUD
  /ut:generate/ui: 基础页面结构，最小化设计

代码生成命令:
  /ut:code/frontend: MVP前端，基础功能实现
  /ut:code/backend: MVP后端，核心API实现  
  /ut:code/mock: 简化Mock数据
  /ut:code/integrate: 基础集成测试

验证检查命令:
  /ut:validate/specs: 基础文档检查，跳过详细验证
  /ut:validate/api: API可用性检查，跳过性能测试
  /ut:validate/coverage: 60%覆盖率目标
```

## ⚡ 输出风格调节

### 代码生成特点
```yaml
代码风格:
  注释程度: 仅关键逻辑注释
  错误处理: 基础try-catch，简化错误信息
  设计模式: 简单直接，避免过度抽象
  性能优化: 基础优化，暂缓深度优化

文件结构:
  目录层次: 扁平化结构，减少嵌套
  模块分离: 基础分离，暂缓过度拆分
  配置文件: 最小化配置，使用默认值

测试策略:
  测试类型: 主要功能测试，跳过边界测试
  覆盖率目标: 60%，核心功能覆盖
  测试数据: 简化测试用例，基础场景
```

### 文档生成特点
```yaml
文档内容:
  详细程度: 要点式描述，避免冗长说明
  示例数量: 1-2个基础示例
  最佳实践: 跳过详细最佳实践说明
  扩展内容: 暂缓高级功能说明

格式风格:
  结构层次: 扁平化结构，2-3层嵌套
  内容密度: 高密度信息，减少解释性文字
  图表使用: 最小化，仅必要的架构图
```

## 🎨 技术选择倾向

### 前端技术简化
```yaml
React生态:
  状态管理: useState为主，避免复杂Redux
  路由管理: React Router基础路由
  UI组件: 原生HTML + 基础CSS，避免复杂UI库
  构建工具: Vite默认配置

样式方案:
  CSS方案: 简单CSS文件，暂缓CSS-in-JS
  响应式: 基础断点，简化适配
  主题系统: 固定主题，暂缓动态切换
```

### 后端技术简化
```yaml
Express.js生态:
  中间件: 基础中间件，cors + helmet
  认证方案: 简化JWT，基础权限控制
  数据验证: 基础Zod验证，简化规则
  
数据库设计:
  ORM选择: Prisma基础功能
  数据模型: 简化关联关系
  索引设计: 基础索引，暂缓复杂优化
  
部署方案:
  容器化: 基础Docker配置
  环境配置: 简化环境变量
  监控日志: 基础console.log
```

## 📋 质量标准调节

### 降低质量门禁
```yaml
代码质量:
  测试覆盖率: 60% (vs 标准模式80%)
  静态检查: 基础ESLint规则
  类型检查: TypeScript基础类型
  性能要求: 基本可用性能

文档质量:
  完整性要求: 70% (vs 标准模式90%)
  一致性检查: 基础一致性检查
  最佳实践: 跳过复杂最佳实践

系统质量:
  错误处理: 基础错误处理
  安全措施: 基础安全检查
  可维护性: 功能优先，后续重构
```

### 时间分配策略
```yaml
总交互预算 ≤ 6次时的分配:
  需求分析: 0.5次 (快速理解核心需求)
  架构设计: 0.5次 (选择熟悉技术栈)
  前端开发: 2次 (MVP界面实现)
  后端开发: 2次 (核心API实现)
  集成测试: 1次 (基础功能验证)

阶段重点:
  T1-T2: 快速PRD + 技术选型
  T3-T4: 前端MVP实现
  T5-T6: 后端MVP + 基础集成
```

## 🔄 自动切换逻辑

### 进入Rush模式条件
```yaml
时间触发:
  剩余交互 ≤ 5次 → 自动建议切换
  交互效率低下 → 建议简化流程
  
用户触发:
  明确要求快速原型
  时间约束明确
  MVP需求明确

任务触发:
  概念验证项目
  学习实验项目
  时间敏感任务
```

### 退出Rush模式条件  
```yaml
时间充裕: 剩余交互 > 10次
质量要求提升: 从原型转向产品
功能复杂度提升: 需要详细设计
```

## 💡 Rush模式最佳实践

### 策略建议
```yaml
需求管理:
  严格P0功能定义: 只做最核心的功能
  延后P1/P2功能: 记录但不实现
  避免需求蔓延: 坚持最小化范围

技术实现:
  选择熟悉技术: 避免学习新技术
  复用现有方案: 最大化代码复用
  简化数据流: 减少状态管理复杂度

测试策略:
  聚焦核心路径: 主要用户流程测试
  手工测试优先: 减少自动化测试投入
  延后性能测试: 先功能后性能
```

### 避免陷阱
```yaml
常见错误:
  过度简化导致不可用
  忽略基础架构导致返工
  跳过关键测试导致问题

预防措施:
  保持最小可用标准
  确保基础架构稳定
  核心功能必须测试
```

## 📊 Rush模式示例

### 用户管理系统MVP
```yaml
Rush模式实现范围:
  P0功能: 用户注册、登录、基础信息管理
  跳过功能: 密码重置、邮箱验证、角色权限
  
技术选择:
  前端: React + useState + 基础CSS
  后端: Express + JWT + PostgreSQL  
  测试: 基础功能测试

预期交互消耗:
  需求分析: 0.5次
  技术架构: 0.5次  
  前端实现: 2次
  后端实现: 2次
  集成测试: 1次
  总计: 6次
```

Rush模式确保在最紧张的时间约束下，仍能交付可用的MVP产品，为后续迭代奠定基础。